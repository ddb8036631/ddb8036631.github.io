---
title: "[운영체제] 메인 메모리"
date: 2021-1-14 15:00:00 +0900
categories:
  - os
toc: true
classes: wide
---

# 논리 주소와 물리 주소

- 논리 주소 : CPU가 생성하는 주소
- 물리 주소 : 메모리가 취급하게 되는 주소
- 컴파일, 적재 시간에 주소를 바인딩하면 논리 주소와 물리 주소가 같다.
- 실행 시간에 주소를 바인딩하면 논리 주소와 물리 주소는 다르다. 프로그램 실행 중에 MMU(Memory Management Unit)이 가상 주소를 물리 주소로 바꿔준다.

# 주소 공간

- 시스템이 올바르게 동작하기 위해서는 각각의 프로세스들은 독립된 메모리 공간을 가져 프로세스 사이도 서로 보호해야 한다.
- 프로세스가 메모리를 접근할 때 사용하는 주소들의 집합으로 각 프로세스는 자신만의 주소 공간을 갖는다.
- 개별적인 프로세스별 메모리 공간은 서로를 보호하고 병행 실행을 위해 여러 프로세스가 메모리에 적재되게 해야한다.
- base와 limit 레지스터를 이용해 주소 공간을 정의한다. base 레지스터에는 프로그램이 적재된 **메모리 시작 위치**가, limit 레지스터에는 **프로그램의 크기**가 저장된다.

  ![/assets/images/OS_메인 메모리1.png](/assets/images/OS_메인 메모리1.png)

# 동적 적재(Dynamic Loading)

- 프로세스가 시작될 때, 프로세스의 주소 공간 전체를 메모리에 올려 놓는 것이 아니라 메모리를 좀 더 효율적으로 사용하기 위해, 필요한 루틴(함수)이 호출될 때, 해당 루틴을 메모리에 적재하는 방식을 말한다.

# 동적 연결 라이브러리(Dynamic Linking Library, DLL), 공유 라이브러리(Shared Library)

- 라이브러리가 프로그램 내부에 있는 것이 아니라, 따로 독립적으로 실행 가능한 파일의 형태로 존재하다가 프로그램이 실행될 때 동적으로 링크되어 사용된다.

장점

- 각 프로세스에 라이브러리를 포함시키지 않아도 되므로, 메인 메모리를 낭비하지 않는다.
- 여러 프로세스 간에 공유가 가능하다. 따라서 공유 라이브러리라고도 불린다.

# 스와핑

![/assets/images/OS_메인 메모리2.png](/assets/images/OS_메인 메모리2.png)

- 스와핑 : 한 프로세스의 모든 이미지가 메모리로 적재되어 실행하다가, 더이상 실행되지 않을 경우 다시 디스크로 내려 보내는 방법.
- 현재 실행되고 있지 않은 프로세스는 메모리를 차지하지 않고 디스크에 존재하게 된다.
- 스와핑 결과, 여러 개의 분리된 빈 공간(hole)이 만들어지며, 빈 공간들을 모아 하나의 큰 공간으로 합칠 수 있다. 이를 메모리 조각 모음(memory compaction)이라고 한다.

# 가용 메모리 공간 관리 방법

- 최초 적합(first-fit) : 첫 번째 가용 공간을 할당한다.
- 최적 적합(best-fit) : 가용 공간 중 가장 작은 것을 택한다.
- 최악 적합(worst-fit) : 가장 큰 가용 공간을 택한다.
- 최초 적합이 일반적으로 최적 적합보다 빠르다.

# 단편화(Fragmentation)

- 단편화 : 메모리의 빈 공간이 여러 개의 조각으로 나뉘는 현상
- 외부 단편화 : 남은 유휴 공간들을 합치면 프로세스를 실행시키기에 충분한 공간이 되지만, 여러 조각들로 분산되어 있으므로 작업을 받아들이지 못하는 상황을 말한다.

  ![/assets/images/OS_메인 메모리3.png](/assets/images/OS_메인 메모리3.png)

- 내부 단편화 : 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어 내부에 낭비되는 빈 공간이 생기는 현상을 말한다.

  ![/assets/images/OS_메인 메모리4.png](/assets/images/OS_메인 메모리4.png)

- 단편화 해결 방법
  1. 압축(compaction)
     - 메모리에 존재하는 단편화 영역들을 한 곳으로 밀착시켜 모음
     - 프로그램의 재배치가 필요함
  2. 통합(coalescing)
     - 인접한 단편화 영역들을 합침
     - 프로그램 재배치가 필요하지 않음
  3. 페이징
     - 가상 메모리를 같은 크기의 블록으로 나누고, 그 단위는 페이지(page)라고 한다.
     - 주기억장치를 나눈 조각을 프레임(frame)이라고 한다.
     - 외부 단편화는 해결 되지만, 내부 단편화는 해결되지 않는다.
  4. 세그멘테이션(Segmentation)
     - 페이징 기법과 유사
     - 같은 크기로 나누지 않고 서로 다른 크기로 나누고, 그 단위는 세그먼트(segment)라고 한다.
     - 내부 단편화는 해결 되지만, 외부 단편화는 해결되지 않는다.
  5. 메모리 풀(Memory Pool)
     - 메모리의 일정 공간을 미리 할당하고, 동적 할당을 해 그 공간을 채워주는 기법.
     - 할당 받았던 메모리 공간 사용이 끝나면 반납하기 때문에 외부 단편화가 생기지 않는다.
     - 필요한 크기만큼 할당을 해놓기 때문에 내부 단편화 또한 생기지 않는다.
     - 내부 단편화, 외부 단편화 둘 다 해결 가능

# 페이징(Paging)

![/assets/images/OS_메인 메모리5.png](/assets/images/OS_메인 메모리5.png)

- 사용하지 않는 프레임을 페이지에 옮기고(swap-out), 필요한 메모리를 페이지 단위로 프레임에 옮기는(swap-in) 기법이다.
- 페이지(page) : 논리 메모리의 작은 고정 사이즈로, 프로세스를 균일하게 자른 단위
- 프레임(frame) : 페이지와 같은 크기의 물리 메모리의 조각
- 위의 메모리 관리 방법들과는 다르게, 페이징은 주소 공간이 연속적이지 않아도 된다.
- 페이지 번호는 페이지 테이블의 인덱스로 사용된다. 페이지 테이블에는 해당 페이지 번호에 대응되는 페이지 프레임 번호가 기록되어 있다.
- 페이징 기법을 사용하면 외부 단편화가 발생하지 않는다. 하지만, 각 프로세스의 마지막 페이지에서는 내부 단편화가 발생한다.
- 페이지 테이블은 메인 메모리에 저장된다.

# Translation Look-Aside Buffer(TLB) 페이징 속도 향상

- 대부분의 프로그램들이 적은 개수의 페이지들을 집중적으로 참조하는 경향이 있다. 결국, 페이지 테이블 엔트리 중 일부만 빈번히 참조되며, 다른 엔트리들은 드물게 참조되는 것이다.
- TLB : 고속 캐시의 일종으로, 페이지 테이블 참조 없이 가상 주소를 물리 주소로 매핑할 수 있는 작은 하드웨어다.
- TLB는 MMU 내부에 위치한다.

작동 과정

- TLB에 페이지를 찾아달라는 요청이 들어오면, 찾고자 하는 페이지를 TLB 내의 키와 비교한다.
- 페이지 번호가 같은 것이 발견되면, 대응하는 프레임 번호를 알려준다.
- 페이지 번호가 존재하지 않는다면, MMU는 페이지 테이블을 검색하여 해당 페이지 테이블 엔트리를 찾는다. 그리고 TLB 엔트리 중 하나를 선택해 새로 찾은 페이지 테이블 엔트리 내용을 기록한다. (TLB 미스)
