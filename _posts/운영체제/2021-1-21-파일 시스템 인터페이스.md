---
title: "[운영체제] 파일 시스템 인터페이스"
date: 2021-1-21 16:21:00 +0900
categories:
  - os
toc: true
classes: wide
---

# 파일 개념

- 파일은 **관련된 정보들의 집합**을 말한다.
- 보통 **비휘발성의 보조기억장치**에 저장된다.

<br>

# 파일 연산

1. 파일 생성 : 파일 시스템 내에 파일을 저장할 수 있는 공간을 찾고, 새로 생성된 파일 항목을 디렉터리에 만든다.
2. 파일 열기 : 파일에 대한 생성과 삭제를 제외한 모든 연산을 하기 전에 반드시 파일 open) 시스템 콜을 해야 한다. open() 시스템 콜이 성공하면 열린 파일 핸들을 반환한다.
3. 파일 쓰기 : 열린 파일 핸들과 파일에 기록될 정보를 명시하는 시스템 콜을 실행한다. 파일 시스템은 **쓰기 포인터**를 유지하는데, 이는 다음 번 쓰기가 일어날 위치를 가리킨다.
4. 파일 읽기 : 파일 핸들과 파일이 읽혀야 할 블록의 위치를 기술하는 시스템 콜을 사용한다. 쓰기와 마찬가지로 다음 번 읽기가 일어날 위치를 가리키는 **읽기 포인터**를 유지한다.
5. 파일 안에서의 위치 재설정 : 탐색으로도 알려진 이 연산은 열린 파일의 현재 파일 위치(파일 포인터)를 주어진 값으로 설정한다.
6. 파일 삭제 : 지정된 파일을 디렉터리에서 찾는다. 찾으면 모든 파일 공간을 해제하고, 디렉터리의 항목을 지우거나 사용 가능으로 표시한다.
7. 파일 절단 : 파일의 내용은 지우고 속성은 그대로 남기기를 원할 때 사용한다.

<br>

# 파일 접근 방법

## 순차 접근

- 파일을 저장되어 있는 레코드 순서로 접근한다.
- 편집기나 컴파일러가 사용하는 방식이다.
- read시 현재 위치를 추적하는 파일 포인터(offset)가 자동으로 증가한다.
- write시 파일의 끝에 추가하며, 새로운 파일의 끝으로 파일 포인터가 이동한다.

## 직접 접근

- 파일은 고정 길이의 논리 레코드의 집합으로 정의되고, 직접 접근 파일은 어떠한 블록이라도 직접 액세스할 수 있다.
- 직접 접근 방식은 파일의 디스크 모델에 기반한다. 디스크가 임의의 파일 블록에 임의적 접근을 허용하기 때문이다.
- 직접 접근 파일에는 읽기나 쓰기의 순서에 제약이 없다.
- 대규모의 정보를 다루는 데 유용하다.
- 실제 절대적인 파일의 블록 번호와 상관없이 운영체제가 `상대 블록 번호` 를 지정하고, 이 번호를 갖고 파일 접근이 가능하다. 따라서, 상대 블록 번호를 사용하기 위해서 운영체제는 파일이 어디에 저장되야 하는지를 결정해야만 하고, 사용자가 자신의 파일이 아닌 부분에 접근하는 것을 막을 수 있게 해야 한다.

<br>

모든 운영체제가 순차 접근과 직접 접근을 둘 다 제공하지는 않는다. 직접 접근 파일을 이용해 순차 접근 파일 기능을 구현할 순 있지만, 반대로 순차 접근 파일을 이용해 직접 접근을 흉내내는 것은 비효율적이다.

<br>

# 디렉터리 구조

## 1단계 디렉터리

![http://dl.dropbox.com/s/tc02xaoi2x62xg8/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%8C%8C%EC%9D%BC%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-1.png](http://dl.dropbox.com/s/tc02xaoi2x62xg8/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%8C%8C%EC%9D%BC%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-1.png)

- **모든 파일이 하나의 디렉터리 밑에** 존재한다.
- 파일의 이름은 유일해야 하므로, 파일이 많아지거나 다수의 사용자가 사용하는 시스템에서는 제약이 있다.

<br>

## 2단계 디렉터리

![http://dl.dropbox.com/s/45c0ve322zbzdrn/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%8C%8C%EC%9D%BC%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-2.png](http://dl.dropbox.com/s/45c0ve322zbzdrn/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%8C%8C%EC%9D%BC%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-2.png)

- 각 사용자는 자신만의 UFD(User File Directory, UFD)를 갖으며, **각 디렉터리에 한 사람의 파일들**만 저장한다.
- 사용자 작업이 시작되거나 시스템에 사용자가 로그인 등을 통해 접속하면 시스템이 먼저 MFD(Master File Directory, MFD)를 탐색해 사용자 이름이나 계정 번호로 UFD를 찾고 이를 가리킨다.
- 위 작업이 끝난 이후, 사용자가 파일을 시스템에 제시하면, 찾은 UFD 내에서만 탐색한다. 따라서 UFD내에서 파일 이름이 유일하다면, 다른 사용자들이 동일한 이름의 파일을 가져도 상관 없다.
- 한 사용자의 UFD를 다른 사용자가 액세스할 수 없으므로, 파일 이름이 충돌하는 문제는 해결됐지만, **서로가 자신의 UFD 접근을 허용하지 않으면 파일 공유가 불가능**하다는 문제가 생긴다.

<br>

## 트리 구조 디렉터리

![http://dl.dropbox.com/s/yh4oejwxl8naggp/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%8C%8C%EC%9D%BC%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-3.png](http://dl.dropbox.com/s/yh4oejwxl8naggp/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%8C%8C%EC%9D%BC%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-3.png)

- 2단계 디렉터리 구조를 일반화하여 확장하면 트리 구조 디렉터리가 된다.
- 사용자에게 서브디렉터리를 얼마든지 만들 수 있도록 해준다. 즉, 디렉터리 하부에 다시 디렉터리나 파일을 가질 수 있다.
- 트리 구조에서는 디렉터리 삭제 문제가 발생한다.
    - 빈 디렉터리는 그냥 지우면 된다.
    - 하지만 파일들이나 다른 서브디렉터리들로 채워져 있다면,
        1. 삭제를 하지 못하게 시스템 콜을 막을 수 있고, 또는
        2. 안에 들어있는 모든 파일들과 서브디렉터리들도 지울 수도 있다.