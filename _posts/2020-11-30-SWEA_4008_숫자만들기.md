---
title: "[알고리즘 풀이] SWEA - 4008. [모의 SW 역량테스트] 숫자 만들기"
date: 2020-11-30 23:38:00 +0900
categories:
  - 알고리즘 풀이
toc: true
toc_sticky: true
---

# 문제 링크

> [SWEA - 4008. [모의 SW 역량테스트] 숫자 만들기](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeRZV6kBUDFAVH&categoryId=AWIeRZV6kBUDFAVH&categoryType=CODE)

# 풀이 과정

처음에는 연산자의 개수를 토대로 순열을 만들어 계산을 했지만, 시간 초과가 났습니다. 이에 재귀 함수를 호출해 순열이 다 만들어 지면 계산을 하는 방법이 아닌, 만들면서 계산까지 하는 방식으로 문제를 풀었습니다.

# 코드

아래는 시간초과가 난 코드입니다.

```java
package SWEA_모의SW역량테스트;

import java.util.ArrayList;
import java.util.Scanner;

public class SWEA_4008_숫자만들기 {
    static int max;
    static int min;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int TC = sc.nextInt();

        for (int tc = 1; tc <= TC; tc++) {
            max = Integer.MIN_VALUE;
            min = Integer.MAX_VALUE;

            ArrayList<Character> opList = new ArrayList<>();
            int N = sc.nextInt();

            for (int i = 0; i < 4; i++) {
                int count = sc.nextInt();
                char op = '\0';

                switch (i) {
                    case 0:
                        op = '+';
                        break;
                    case 1:
                        op = '-';
                        break;
                    case 2:
                        op = '*';
                        break;
                    case 3:
                        op = '/';
                        break;
                }

                while (count-- > 0) {
                    opList.add(op);
                }
            }

            int[] num = new int[N];
            for (int i = 0; i < N; i++)
                num[i] = sc.nextInt();

            perm(0, N - 1, opList, num);

            System.out.println("#" + tc + " " + (max - min));
        }
    }

    private static void perm(int depth, int r, ArrayList<Character> opList, int[] num) {
        if (depth == r) {
            solve(num, opList);
            return;
        }

        for (int i = depth; i < r; i++) {
            swap(i, depth, opList);

            perm(depth + 1, r, opList, num);

            swap(i, depth, opList);
        }
    }

    private static void swap(int i, int j, ArrayList<Character> opList) {
        char tmp = opList.get(i);
        opList.set(i, opList.get(j));
        opList.set(j, tmp);
    }

    private static void solve(int[] num, ArrayList<Character> opList) {
        int sum = num[0];

        for (int i = 1; i < num.length; i++) {
            switch (opList.get(i - 1)) {
                case '+':
                    sum += num[i];
                    break;
                case '-':
                    sum -= num[i];
                    break;
                case '*':
                    sum *= num[i];
                    break;
                case '/':
                    sum /= num[i];
                    break;
            }
        }

        max = Math.max(max, sum);
        min = Math.min(min, sum);
    }
}
```

아래 코드와 같이 수정 후 통과했습니다.

```java
package SWEA_모의SW역량테스트;

import java.util.Scanner;

public class SWEA_4008_숫자만들기 {
    static int N;
    static int[] operator;
    static int[] operand;
    static int max;
    static int min;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int TC = sc.nextInt();

        for (int tc = 1; tc <= TC; tc++) {
            max = Integer.MIN_VALUE;
            min = Integer.MAX_VALUE;

            N = sc.nextInt();

            operator = new int[4];
            for (int i = 0; i < 4; i++)
                operator[i] = sc.nextInt();

            operand = new int[N];
            for (int i = 0; i < N; i++)
                operand[i] = sc.nextInt();

            solve(1, operand[0]);

            System.out.println("#" + tc + " " + (max - min));
        }
    }

    private static void solve(int depth, int sum) {
        if (depth == N) {
            max = Math.max(max, sum);
            min = Math.min(min, sum);

            return;
        }

        for (int i = 0; i < 4; i++) {
            if (operator[i] == 0)
                continue;

            operator[i]--;

            switch (i) {
                case 0:
                    solve(depth + 1, sum + operand[depth]);
                    break;
                case 1:
                    solve(depth + 1, sum - operand[depth]);
                    break;
                case 2:
                    solve(depth + 1, sum * operand[depth]);
                    break;
                case 3:
                    solve(depth + 1, sum / operand[depth]);
                    break;
            }

            operator[i]++;
        }
    }
}
```
