---
title: "[알고리즘 풀이] 백준 - 9370. 미확인 도착지"
date: 2021-2-8 22:48:00 +0900
categories:
  - 알고리즘 풀이
toc: true
classes: wide
---

# 문제 링크

> [백준 - 9370. 미확인 도착지](https://www.acmicpc.net/problem/9370)

<br>

# 풀이 과정

다익스트라 알고리즘을 적용해 풀 수 있는 문제입니다. 시작 정점으로부터 목적지 후보 정점에 도착했을 때, 최단 거리 경로에 g-h 간선이 포함되는 지 판단해야 합니다.

![/assets/images/백준_9370_미확인 도착지-1.png](/assets/images/백준_9370_미확인 도착지-1.png)

문제를 풀며 주의해야 할 조건은 다음과 같습니다.

1. g-h 간선의 사용 유무를 저장해 두어야 합니다.
2. 정점까지 같은 비용으로 가더라도, g-h 간선을 포함해 가는 경로가 있다면, 해당 정점까지는 g-h 간선을 이용해 간 것으로 설정해 줘야 합니다.

<br>

```java
private static class Edge {
    int vertex, cost;
}

private static class Info {
    int dist;
    boolean used;
}
```

위 코드와 같이 간선 정보를 저장하는 클래스 Edge와 별개로, 간선에 대한 최단 거리( `dist` ) 및 g-h 간선의 사용 유무( `used` )를 체크하기 위한 Info 클래스를 하나 두었습니다.

<br>

또한, 정점까지 도달하는 데에 드는 비용이 같다면, 이전 경로는 무시하고 g-h 간선을 사용하도록 해주어야 합니다.

![/assets/images/백준_9370_미확인 도착지-2.png](/assets/images/백준_9370_미확인 도착지-2.png)

![/assets/images/백준_9370_미확인 도착지-3.png](/assets/images/백준_9370_미확인 도착지-3.png)

위 예시처럼, 같은 비용의 다른 경로가 존재하고, 그 경로(파란색 경로)가 **g-h 간선을 포함**한다면, g-h 간선을 이용해 간 것으로 판단해줘야 합니다. 다시 말해, g-h 간선을 **이용해서** 도달이 가능하다고 판단해 주어야 합니다.

<br>

```java
for (Edge next : adj[now.vertex]) {
    if (!visit[next.vertex] && infos[next.vertex].dist >= infos[now.vertex].dist + next.cost) {
        if(infos[next.vertex].used && infos[next.vertex].dist == infos[now.vertex].dist + next.cost) continue;

        infos[next.vertex].dist = infos[now.vertex].dist + next.cost;
        infos[next.vertex].used = infos[now.vertex].used;

        Edge edge = new Edge(next.vertex, infos[next.vertex].dist);

        pq.add(edge);

        if ((now.vertex == g && next.vertex == h) || (now.vertex == h && next.vertex == g)) {
            infos[next.vertex].used = true;
        }
    }
}
```

아직 방문하지 않은 인접한 정점에 대해 아래와 같은 과정을 거칩니다.

1. 다음 정점에 대해, **이미 저장되어 있는 최소 비용**과 현재 정점까지의 최소 비용에 **다음 정점까지의 비용을 더했을 때의 비용**이 **같고**, g-h 간선을 사용한 이력이 있으면 갱신 및 큐에 삽입하는 과정은 생략합니다.
2. **이미 저장되어 있는 최소 비용**보다 현재 정점까지의 최소 비용에 **다음 정점까지의 비용을 더했을 때의 비용**이 **작다면**, 갱신시켜 줍니다. 이 때, 현재 정점과 다음 정점이 g, h 쌍이라면 g-h 간선의 사용 유무를 체크(used 를 true 로) 해줍니다.

<br>

# 코드

```java
package 다익스트라;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class BOJ_9370_미확인도착지 {
    static int n, m, t, s, g, h;
    static ArrayList<Edge>[] adj;
    static Info[] infos;
    static boolean[] visit;
    static TreeMap<Integer, Boolean> candidate;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int TC = Integer.parseInt(br.readLine());

        for (int tc = 1; tc <= TC; tc++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            n = Integer.parseInt(st.nextToken());
            m = Integer.parseInt(st.nextToken());
            t = Integer.parseInt(st.nextToken());

            st = new StringTokenizer(br.readLine());
            s = Integer.parseInt(st.nextToken());
            g = Integer.parseInt(st.nextToken());
            h = Integer.parseInt(st.nextToken());

            adj = new ArrayList[n + 1];
            for (int i = 1; i <= n; i++)
                adj[i] = new ArrayList<>();

            infos = new Info[n + 1];
            for (int i = 1; i <= n; i++)
                infos[i] = new Info(Integer.MAX_VALUE, false);

            visit = new boolean[n + 1];

            for (int i = 0; i < m; i++) {
                st = new StringTokenizer(br.readLine());
                int v1, v2, cost;

                v1 = Integer.parseInt(st.nextToken());
                v2 = Integer.parseInt(st.nextToken());
                cost = Integer.parseInt(st.nextToken());

                adj[v1].add(new Edge(v2, cost));
                adj[v2].add(new Edge(v1, cost));
            }

            candidate = new TreeMap<>();
            for (int i = 0; i < t; i++)
                candidate.put(Integer.parseInt(br.readLine()), false);

            PriorityQueue<Edge> pq = new PriorityQueue<>(new Comparator<Edge>() {
                @Override
                public int compare(Edge o1, Edge o2) {
                    return o1.cost - o2.cost;
                }
            });

            infos[s].dist = 0;
            Edge start = new Edge(s, 0);
            pq.add(start);

            while (!pq.isEmpty()) {
                Edge now = pq.poll();
                visit[now.vertex] = true;

                if (candidate.containsKey(now.vertex) && infos[now.vertex].used) {
                    candidate.put(now.vertex, true);
                }

                for (Edge next : adj[now.vertex]) {
                    if (!visit[next.vertex] && infos[next.vertex].dist >= infos[now.vertex].dist + next.cost) {
                        if(infos[next.vertex].used && infos[next.vertex].dist == infos[now.vertex].dist + next.cost) continue;

                        infos[next.vertex].dist = infos[now.vertex].dist + next.cost;
                        infos[next.vertex].used = infos[now.vertex].used;

                        Edge edge = new Edge(next.vertex, infos[next.vertex].dist);

                        pq.add(edge);

                        if ((now.vertex == g && next.vertex == h) || (now.vertex == h && next.vertex == g)) {
                            infos[next.vertex].used = true;
                        }
                    }
                }
            }

            for (Map.Entry entry : candidate.entrySet()) {
                if ((boolean) entry.getValue()) {
                    System.out.print(entry.getKey() + " ");
                }
            }
            System.out.println();
        }
    }

    private static class Edge {
        int vertex, cost;

        public Edge(int vertex, int cost) {
            this.vertex = vertex;
            this.cost = cost;
        }
    }

    private static class Info {
        int dist;
        boolean used;

        public Info(int dist, boolean used) {
            this.dist = dist;
            this.used = used;
        }
    }
}
```