---
title: "[알고리즘 정리] 최장 증가 부분 수열(Longest Increasing Subsequence, LIS)"
date: 2021-6-15 16:00:00 +0900
categories:
  - algorithm
toc: true
classes: wide
---

**LIS 알고리즘**은 주어진 **수열 내에서 가장 긴 부분 수열의 길이**를 찾아내는 알고리즘입니다.

예를 들어, `[3, 7, 5, 2, 6, 1, 4]`라는 수열이 주어졌을 때, 증가하는 부분 수열은 `[3, 5]`, `[3, 5, 6]`, `[1, 4]` 로, 총 **세 가지**가 존재합니다.

LIS를 구하는 알고리즘으로는 2가지가 있습니다.

1. 동적 계획법
2. 이분 탐색

<br>

# 동적 계획법

먼저 동적 계획법을 사용한 알고리즘을 살펴보겠습니다.

<br>

```java
for (int i = 0; i < N; i++) {
    dp[i] = 1;

    for (int j = 0; j < i; j++) {
        if (arr[j] < arr[i] && dp[j] + 1 > dp[i]) {
            dp[i] = dp[j] + 1;
        }
    }
}
```

 `dp[i]` 는 **i**번째 요소까지 진행했을 때의 **최장 증가 부분 수열의 길이**를 담고 있습니다.

Bottom-up 방식의 DP를 사용하며, 이중 for문으로 작성됩니다. 작동 과정은 다음과 같습니다.

1. **i**번째 요소를 기준으로 잡습니다.
2. **j**를 0부터 시작해 i전까지 증가시키며, 각 요소 값을 i번째 요소와 비교해, **증가하는 양상**을 보이는 지 확인합니다.
3. 2에서 증가하는 부분 수열임이 확인되면, 메모된 값을 비교해 갱신합니다.

<br>

아래 예시를 통해 배열 dp의 요소들을 채워보도록 하겠습니다.

<center><img src="http://dl.dropbox.com/s/dfyufdk4mw7t7dr/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EC%A0%95%EB%A6%AC-%EC%B5%9C%EC%9E%A5%20%EC%A6%9D%EA%B0%80%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4-1.png"></center>

배열 `[3, 7, 5, 2, 6, 1, 4]`에 위 알고리즘을 적용시켜 보겠습니다. 먼저, 현재 i는 4를 가리키며, 이전까지 작업을 통해 dp 배열의 요소들이 갱신됐다고 가정하겠습니다.

먼저, 외부의 for문이 실행되어 새로운 **i**를 가리키면, 해당 요소를 시작으로 새롭게 **증가하는 부분 수열**이 만들어질 수 있기 때문에, `dp[i]`를 **1**로 초기화합니다.

<br>

<center><img src="http://dl.dropbox.com/s/cvoi7h864gjlru3/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%EC%A0%95%EB%A6%AC-%EC%B5%9C%EC%9E%A5%20%EC%A6%9D%EA%B0%80%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4-2.png"></center>

**j**가 **2**를 가리키면, `arr[j] < arr[i]`를 만족하게 됩니다. 이는, 기존의 증가 부분수열에 i번째 요소를 붙였을 때에도 증가하는 부분 수열 `[3, 5, 6]`을 만족한다는 것을 의미합니다. 따라서, 이전에 만들었던 부분 수열 `[3, 6]`을 통해 갱신된 **dp[4]** 값 2를, **3**으로 갱신해줍니다.

위처럼 이중 for문을 사용해 동적 계획법으로 작성하면, 시간 복잡도는 $O(N^2)$이 됩니다. 따라서, 전체 배열의 길이가 클수록, 실행 시간이 길어지게 됩니다.

# 이분 탐색

<br>