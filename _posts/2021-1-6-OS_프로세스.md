---
title: "[운영체제] 프로세스"
date: 2021-1-6 22:16:00 +0900
categories:
  - 운영체제
toc: true
classes: wide
---

# 프로세스의 정의

프로세스는 **메모리 상에서 실행 중인 프로그램**을 말한다.

프로세스의 메모리 배치는 다음과 같다.

![/assets/images/프로세스1_1.png](/assets/images/프로세스1_1.png)

프로세스는 실행 코드가 적재된 `텍스트 섹션` 과 함수의 매개변수, 복귀 주소 및 지역 변수 같은 임시 자료를 갖는 `스택 섹션` 과 전역 변수를 갖는 `데이터 섹션` , 프로그램 실행중에 동적으로 할당되는 메모리인 `힙 섹션` 을 포함한다. 텍스트 및 데이터 섹션의 크기는 고정되어 프로그램 실행 동안 크기가 변하지 않지만, 스택과 힙 섹션은 프로그램 실행 중에 동적으로 줄어들거나 커질 수 있다.

<br>

# 프로그램과 프로세스

프로그램은 명령어 리스트를 내용으로 가진 디스크에 저장된 파일과 같은 수동적인 존재다. 이에 반해, 프로세스는 다음에 실행할 명령어를 저장하는 프로그램 카운터와 관련 자원의 집합을 가진 능동적인 존재다. **실행 파일이 메모리에 적재될 때**, 프로그램은 비로소 프로세스가 된다.

<br>

# 프로세스 제어 블록(Process Control Block, PCB)

각 프로세스는 운영체제에서 프로세스 제어 블록에 의해 표현된다. 프로세스 제어 블록은 특정 프로세스와 연관된 여러 정보를 수록하며, 다음과 같은 것들을 포함한다.

- 프로세스 상태 : new, ready running, waiting, halted 등의 상태를 저장한다.
- 프로세스 번호 : 프로세스 식별 변호(PID)
- 프로그램 카운터 : 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.
- CPU 레지스터
- CPU-스케줄링 정보 : 프로세스 우선순위, 스케줄 큐에 대한 포인터와 다른 스케줄 매개변수를 포함한다.
- 메모리 관리 정보 : base 레지스터 및 limit 레지스터의 값과 페이지 테이블 또는 세그먼트 테이블 등의 정보를 포함한다.
- 어카운팅 정보 : CPU 사용 시간과 경과된 실시간, 시간 제한, 계정 번호, 작업 또는 프로세스 번호 등을 포함한다.
- 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다.

<br>

# 프로세스 스케줄링

프로세스 스케줄링은 수행 가능한 여러 프로세스들 중에서 하나의 프로세스를 선택하는 작업을 말하고, 이 작업을 프로세스 스케줄러가 수행한다. 각 CPU 코어는 한 번에 하나의 프로세스를 실행할 수 있다.

**다중 프로그래밍**은 CPU의 이용률을 극대화하기 위해 항상 어떤 프로세스가 실행되도록 하고, **시분할**은 다중 프로그래밍을 확장한 개념으로, 각 프로그램이 실행되는 동안 사용자가 상호작용 할 수 있도록 프로세스들 사이에서 CPU를 빈번히 교체한다.

대부분의 프로세스들은 I/O  bound 혹은 CPU bound로 프로세스의 우선순위가 결정된다. I/O 바운드 프로세스는 계산(CPU)에 소비하는 것보다 Input 및 Output에 더 많은 시간을 소모하는 프로세스이다. 반면에 CPU 바운드 프로세스는 I/O 요청을 적게 받고, 대부분의 시간을 CPU를 사용해 계산 작업을 하는 방식이다.

## 스케줄링 큐

스케줄링 큐의 종류로는 작업 큐, 준비 큐, 장치 큐가 있다.

- 작업 큐 : 시스템 내 모든 프로세스들을 관리하기 위한 큐이다. 프로세스 상태와 무관하게 현재 시스템 내에 있는 모든 프로세스가 작업큐에 속하게 된다.
- 준비 큐 : CPU를 할당받고 실행될 준비가 된 모든 프로세스들을 관리하기 위한 큐이다. 시스템에 하나 존재하며, 이 중에서 프로세스를 하나 선택하고 프로세스는 실행된다.
- 장치 큐 : I/O 장치를 기다리는 모든 프로세스들을 관리하는 큐이다.

## CPU 스케줄링

스케줄링 대상은 준비 큐에 있는 프로세스들이다.

CPU 스케줄링 알고리즘은 클럭 인터럽트를 어떻게 다루는 가에 따라 `비선점형 스케줄링 알고리즘` 과 `선점형 스케줄링 알고리즘` 으로 나뉜다.

- 비선점형 스케줄링 알고리즘 : I/O나 다른 프로세스를 기다리기 위해 대기하거나 자발적으로 CPU를 반환할 때까지 계속 수행할 수 있다.
- 선점형 스케줄링 알고리즘: 정해진 시간이 끝나면 프로세스는 중단되고, 스케줄러는 다음에 실행할 다른 프로세스를 선정한다.

### FCFS(First Come First Served)

특징

- 프로세스들은 요청 순서대로 CPU를 할당 받는다.
- 프로세스 작업이 아무리 오래 수행되도 끝날 때까지 방해 받지 않는다.
- 비선점형 스케줄링

문제점

- 비교적 짧은 CPU 바운드 프로세스가 긴 I/O 바운드 프로세스가 끝나길 기다리는 상황이 발생할 수 있다.
- 이를 호위 효과(Convoy Effect) 라고 한다.

<br>  

### SJF(Shortest-Job Fisrt)

특징

- 처리 시간이 짧은 프로세스들 순서로 스케줄링하는 방식이다.
- 비선점형 스케줄링

문제점

- 실행 시간이 짧은 프로세스들이 지속적으로 도착한다면, 상대적으로 긴 프로세스는 계속해서 지연되는 단점이 있다. 이를 기아 상태(Starvation)라고 한다.

<br>

### SRTF(Shortest Remaining Time First)

- 비선점형인 SJF 스케줄링의 단점을 보완하기 위해 선점형 방식으로 구현한 스케줄링 알고리즘이다. Shortest Remaining Time Next 로도 불린다.

문제점

- 잦은 Remaning Time 계산, 잦은 선점으로 인해 문맥 교환 오버헤드가 증가한다.
- 이로 인해 현실적으로 구현 및 사용이 어렵다.

<br>

### Round Robin

특징

- 모든 프로세스에 동일한 최대 CPU 사용 시간 할당량(time quantum)을 정해주고, 처리 중인 프로세스의 CPU 실행 시간이 점유 시간을 초과하면 강제로 회수하여 다음 프로세스에 할당하는 방식이다.
- 선점형 스케줄링
- 모든 프로세스들에게 CPU가 할당될 기회를 동일하게 주어지므로, 대화식 시스템 환경에 적합하다.

주의

- time quantum 이 너무 짧으면 잦은 문맥 교환(context switch)으로 오버헤드가 발생해 CPU 효율이 떨어진다.
- 또한 너무 길면 FCFS와 같아져 대화식 요청의 응답의 질이 떨어진다.
- 적절한 time qunatum을 타협하는 것이 중요하다.

<br>

### Priority Scheduling

특징

- 각 프로세스에게 우선순위가 할당되며 가장 높은 우선순위를 가진 실행 가능한 프로세스가 다음에 수행한다.

문제점

- 무한 봉쇄(Indefinite Blocking) : 실행 준비는 되있으나 CPU를 사용하지 못하는 프로세스는 CPU를 기다리면서 봉쇄됨.
- 기아 상태(Starvation) : 낮은 우선순위 프로세스들이 CPU를 무한히 대기하는 경우가 발생한다.

해결책

- 시스템에서 오래 대기하고 있는 프로세스들의 우선순위를 점진적으로 증가시키는 aging 기법을 활용해 해결가능하다.
- 클록 인터럽트마다 현재 실행중인 프로세스의 우선순위를 낮춘다.
- 각 프로세스별로 time quantum을 지정해, 이 할당 시간을 소비하면 다음으로 우선순위가 높은 프로세스에게 실행할 기회를 줄 수도 있다.

<br>

## 문맥 교환(Context Switch)

문맥은 PCB(Process Control Block)에 포함되는 개념으로, `CPU 레지스터의 값, 프로세스 상태, 메모리 관리 정보` 등을 포함한다. [PCB vs Context](https://stackoverflow.com/questions/35147243/process-context-vs-process-control-block)에서 PCB와 Context의 개념 차이를 확인할 수 있다.

멀티 프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때, 기존 프로세스의 문맥을 저장하고, CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 문맥을 복원하는 작업을 문맥 교환이라고 한다.

교환이 일어나는 동안, 시스템은 아무런 유용한 일을 하지 못하기 때문에, 문맥 교환 시간은 순수한 오버헤드다.

![/assets/images/프로세스1_2.png](/assets/images/프로세스1_2.png)