---
title: "[네트워크] 트랜스포트 계층"
date: 2021-2-17 20:30:00 +0900
categories:
  - 네트워크
toc: true
classes: wide
---

# 트랜스포트 계층과 네트워크 계층 사이의 관계

- 트랜스포트 계층 프로토콜은 **프로세스**들 사이의 논리적 통신을 제공한다.
- 네트워크 계층 프로토콜은 **호스트**들 사이의 논리적 통신을 제공한다.
- 트랜스포트 계층 프로토콜은 종단 시스템에 존재하며, 애플리케이션 프로세스에서 네트워크 계층까지 메세지를 운반하며, 또한 반대로 네트워크 계층에서 애플리케이션 프로세스로 메시지를 운반한다.
- 트랜스포트 계층은 하위 네트워크 프로토콜이 **비신뢰적**일 때, 즉 네트워크 프로토콜이 패킷을 분실하거나 손상하거나 복사본을 만들 때에도, **애플리케이션에 신뢰적인 데이터 전송 서비스를 제공할 수 있다**.

<br>

# 트랜스포트 계층 개요

- **TCP**(Transmission Control Protocol)는 애플리케이션에 **신뢰적**이고 **연결지향형** 서비스를 제공한다.
- **UDP**(User Datagram Protocol)는 애플리케이션에게 **비신뢰적**이고 **비연결형** 서비스를 제공한다.
- 트랜스포트 계층 패킷은 **세그먼트**(segment)라고 한다.
- TCP와 UDP는 헤더에 오류 검출 필드를 포함함으로써 **무결성 검사**를 제공한다.
- TCP는 **흐름제어**, **순서번호**, **확인응답**, **타이머**를 사용하면서 데이터가 **순서대로 정확히** 전달되도록 한다. 이를 통해, 네트워크 계층 프로토콜인 IP 프로토콜의 비신뢰적인 서비스를 프로세스 간 신뢰적인 서비스로 만들어 준다.
- TCP 혼잡 제어는 TCP 연결이 과도한 양의 트래픽으로 모든 통신하는 호스트들 사이의 스위치와 링크를 폭주를 막는 것을 의미한다.

<br>

# 다중화와 역다중화

- 다중화(multiplexing) 및 역다중화(demultiplexing)은 호스트 대 호스트 전달 서비스를 프로세스 대 프로세스 전달 서비스로 확장하는 것을 의미한다.
- **다중화**는 소켓으로부터 데이터를 모아 세그먼트 생성을 위해 헤더를 붙여 캡슐화 과정을 거치고, 만들어진 세그먼트들을 네트워크 계층으로 전달하는 작업을 일컫는다.
- 역다중화는 다중화의 반대로, 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업을 일컫는다.
- 다중화와 역다중화는 소켓의 **출발지 포트 번호 필드**와 **목적지 포트 번호 필드**를 통해 이뤄진다. 이 두 필드를 통해 소켓을 식별할 수 있기 떄문이다.

<br>

# 비연결형 다중화와 역다중화

- 두 개의 UDP 세그먼트들이 출발지 IP 주소와 출발지 포트 번호가 모두 다르거나, 어느 한 가지만 다를지라도, **동일한 목적지 IP 주소와 목적지 포트 번호를 가지면**, 두 세그먼트들은 같은 목적지 소켓을 갖는 동일한 프로세스로 향하게 된다.

<br>

# 연결지향형 다중화와 역다중화

- TCP 소켓은 출발지 IP 주소, 출발지 포트 번호, 목적지 IP 주소, 목적지 포트 번호에 의해 식별된다.
- 호스트로 TCP 세그먼트가 도착하면, 호스트는 역다중화하기 위해 위의 네 값을 모두 사용한다.
- UDP와는 다르게, 다른 출발지 주소 또는 다른 출발지 포트 번호를 가지고 도착하는 두 개의 TCP 세그먼트는 두 개의 다른 소켓으로 향하게 된다.

<br>

# UDP

- TCP에 반하는 UDP만의 장점
    1. 연결 설정이 없다.
        - UDP는 3-way handshake 과정이 없다. 따라서, 연결 설정을 위한 지연이 없다.
    2. 연결 상태가 없다. 
        - TCP는 종단 시스템에서 연결 상태를 유지한다. 이에 반해, UDP는 연결 상태를 유지하지 않는다. 이로 인해 TCP보다 좀 더 많은 클라이언트를 수용할 수 있다.
    3. 작은 패킷 헤더 오버헤드를 갖는다.
        - TCP가 세그먼트마다 20바이트의 헤더 오버헤드를 갖는 반면에, UDP는 8바이트의 오버헤드를 갖는다.

<br>

# UDP 세그먼트 구조

![/assets/images/NW_트랜스포트 계층-1.png](/assets/images/NW_트랜스포트 계층-1.png)

- 체크섬은 세그먼트에 오류가 발생했는지를 검사하기 위해 수신 호스트에서 사용된다.
- **UDP 체크섬**은 오류 검출을 제공하며, 비트의 변경사항이 있는지 검사하는 작업을 수행한다. 16비트 워드 단위로 더한 후 1의 보수를 취하며, 오버플로는 윤회식 자리올림(wrap around)한다.

<br>

# 신뢰성 있는 데이터 전송의 원리

- **신뢰적인 채널**에서는 전송된 데이터가 손상되거나 손실되지 않는다. 또한, 모든 데이터는 전송된 순서대로 전달된다.
- 재전송을 기반으로 하는 신뢰적인 데이터 전송 프로토콜은 **자동 재전송 요구 프로토콜(Automatic Repeat reQuest, ARQ)**로 알려져 있다. 또한 비트 오류를 처리하기 위해 **오류 검출**, **수신자 피드백**, **재전송**의 세 가지 부가 기능들이 필요하다.
- 패킷에 **순서 번호(sequence number)**를 추가함으로써 해당 패킷이 재전송 패킷인지 아닌지를 판단할 수 있다.

<br>

# 파이프라이닝 신뢰적 데이터 전송 프로토콜

- rdt3.0의 핵심적인 성능 문제는 stop-and-wait 방식이라는 것이다.
- 이를 해결하기 위해, 송신자에게 확인 응답을 기다리지 않고 여러 패킷을 전송하도록 허용한다. 이러한 신뢰적 데이터 전송 프로토콜 기술을 **파이프라이닝**이라고 한다.
- 파이프라인 오류 회복 방법으로는 **N부터 반복(Go-Back-N, GBN)**과 **선택적 반복(Selective Repeat, SR)**이 있다.

<br>

# N부터 반복(Go-Back-N, GBN)

- **GBN 프로토콜**에서 송신자는 확인응답을 기다리지 않고 여러 패킷을 전송 시 패킷의 개수를 정하여 전송할 수 있다.
- **GBN**은 전송된 프레임이 손상되면, 확인된 마지막 프레임 이후로 보내진 프레임(버퍼 안의 시작 패킷부터 끝까지)을 재전송하는 기법이다. 이 때, 전송하는 버퍼를 윈도우(window)라고 한다.
- **슬라이딩 윈도우(sliding window)**는 송신자와 수신자가 관심을 두고 있는 순서 번호의 영역을 정의하는 개념이다. 슬라이딩 윈도우의 크기가 곧 파이프라인의 크기와 같다. 슬라이딩 윈도우를 사용하므로, GBN을 **슬라이딩 윈도우 프로토콜(sliding-window protocol)**이라고도 부른다.

<br>

# 선택적 반복(Selective Repeat, SR)

- GBN의 비효율성을 해결하기 위한 방식이다.
- **SR**은 손실된 패킷을 확인하여 따로 재전송 할 수 있다. 이를 위해 송신부 뿐만 아니라 수신부에도 버퍼를 둔다.
- 순서에 상관없이 수신하고 응답하여 손실된 패킷만 재전송하고, 수신부 버퍼가 가득 차면 상위 계층으로 한 번에 전달한다.

<br>

# TCP 연결

- TCP는 **연결지향형** 서비스이다. 따라서, 사전에 세그먼트들을 보내 3-way handshake 과정을 거쳐 연결을 먼저 설정해야 한다.
- TCP 연결은 전이중(full-duplex) 서비스를 제공한다. 호스트 A와 호스트 B 사이에 TCP 연결이 존재한다면, 데이터는 A에서 B로 흐르는 동시에, B에서 A로도 흐를 수 있다.
- TCP 연결은 **점대점**(point-to-point)이다. 따라서, 멀티캐스팅은 TCP에서 불가능하다.
- 세그먼트의 크기는 **최대 세그먼트 크기(maximum segment size, MSS)**로 제한된다. MSS는 로컬 송신 호스트에 의해 전송될 수 있는 **가장 큰 링크 계층 프레임의 길이(maximum transmission unit, MTU)**에 의해 결정된다.

<br>

# TCP 세그먼트 구조

![/assets/images/NW_트랜스포트 계층-2.png](/assets/images/NW_트랜스포트 계층-2.png)

- TCP 세그먼트는 헤더 필드와 데이터 필드로 구성되어 있다.
- MSS는 세그먼트의 데이터필드 크기를 제한한다.
- **수신 윈도우** 필드는 흐름 제어에 사용된다.
- **순서 번호**는 데이터 필드 안에 있는 첫 번째 바이트의 바이트 스트림 번호를 의미한다.
- **확인응답 번호**는 호스트가 기다리는 데이터의 다음 바이트의 순서번호를 가리킨다.

<br>

# 재전송 타임아웃 주기

- 신뢰적인 데이터 전송 프로토콜은 재전송을 기반으로 하기 때문에, 재전송을 하기까지의 타임아웃 기간 설정이 중요하다.
- 타임아웃 주기가 너무 작으면 불필요한 재전송이 잦을 것이고, 너무 크면 세그먼트를 잃었을 때 즉각적인 재전송이 이루어지지 않게 된다.
- TCP는 재전송 때마다 타임아웃 주기를 두 배로 설정한다.

<br>

# 신뢰적인 데이터 전달

- 인터넷 프로토콜은 데이터그램 전달을 보장하지 않고, 데이터그램이 순서대로 전달되는 것을 보장하지 않는다.
- TCP는 IP에 신뢰적인 데이터 전달 서비스를 제공한다.

<br>

# 흐름 제어

- **흐름 제어** 서비스는 송신자가 수신자의 버퍼를 오버플로 시키는 것을 방지하기 위해, 수신하는 애플리케이션의 읽는 속도와 송신자가 전송하는 속도를 일치시키는 서비스이다.
- 송신자가 **수신 윈도우(receive window)** 변수를 유지하여 흐름 제어를 제공한다.

<br>

# TCP 연결

![/assets/images/NW_트랜스포트 계층-3.png](/assets/images/NW_트랜스포트 계층-3.png)

- 3 way handshake를 통한 연결 성립 과정은 다음과 같다.
    - 1단계 : 클라이언트는 서버에 SYN 세그먼트를 보낸다.
    - 2단계 : 서버는 클라이언트로 SYNACK 세그먼트를 보낸다.
    - 3단계 : 클라이언트가 SYNACK을 수신하면, 이에 대한 응답을 보낸다. 이 때, 연결은 설정되었기 때문에 SYN 비트는 0으로 설정된다.
- TCP 연결에 대해 버퍼와 변수들을 할당하는 시기는 다음과 같다.
    - 서버가 SYN 세그먼트를 수신할 때
    - 클라이언트가 SYNACK 세그먼트를 수신할 때

<br>

# TCP 연결 종료

![/assets/images/NW_트랜스포트 계층-4.png](/assets/images/NW_트랜스포트 계층-4.png)

- TCP 연결 종료는 다음의 과정을 거친다.
    1. 클라이언트는 서버로 FIN 세그먼트를 보내고, **FIN_WAIT_1** 상태로 들어간다.
    2. 서버는 클라이언트로 ACK을 보내고, 클라이언트는 세그먼트를 수신하면서 **FIN_WAIT_2** 상태로 들어간다.
    3. FIN_WAIT_2 상태에 있는 동안, 클라이언트는 서버가 보내는 FIN 세그먼트를 기다린다.
    4. 서버의 FIN 세그먼트를 받으면 클라이언트는 **TIME_WAIT** 상태로 들어가고, 서버로 ACK를 보낸다.
    5. 서버는 클라이언트의 ACK을 기다리며, TIME_WAIT 기간 내에 ACK가 손실된 경우에는 응답을 재송신하도록 한다.

<br>

# 혼잡 제어

- **혼잡 제어**는 네트워크의 혼잡을 피하기 위해, 송신측에서 보내는 데이터의 전송률을 강제로 줄이는 작업을 말한다.
- **cwnd**라는 이름의 변수로 사용되는 **혼잡 윈도우(congestion window)**는 TCP 송신자가 네트워크로 트래픽을 전송할 수 있는 비율을 제한하도록 한다.
- TCP 혼잡제어 알고리즘은 **슬로 스타트**, **혼잡 회피**, **빠른 회복**으로 구성된다.

<br>

# 슬로 스타트

![/assets/images/NW_트랜스포트 계층-5.png](/assets/images/NW_트랜스포트 계층-5.png)

- TCP 연결 성립 시, cwnd 값은 1MSS로 초기화 된다.슬로 스타트 단계에서는 cwnd 값을 1MSS에서 시작하여, 전송 세그먼트가 첫 번째로 확인응답을 받을 때마다 1MSS씩 증가시킨다.
- 위 방식으로 작동하면, cwnd는 지수 함수의 형태를 띄게 된다.
- 지수적 증가의 끝나는 시점은 다음 세 가지로 나뉜다.
    1. 타임아웃에 의해 패킷 손실일 발생할 경우, TCP 송신자는 cwnd 값을 1로 설정하고, ssthresh(slow start threshold) 값을 cwnd/2로 설정한 뒤, 다시 처음부터 슬로 스타트를 시작한다.
    2. cwnd 값이 ssthresh 값과 같아지면, 슬로 스타트를 종료시키고, **혼잡 회피** 상태로 진입한다.
    3. 3개의 중복 ACK을 받으면, 빠른 재전송을 수행하여 **빠른 회복** 상태로 진입한다.

<br>

# 혼잡 회피

- 슬로 스타트 상태에서 cwnd 값이 ssthresh 값과 같아질 때 혼잡 회피로 진입하게 된다.
- **혼잡 회피** 상태에서는 혼잡 발생 가능성이 크다고 생각을 하고, 이 때 부터는 cwnd 값을 1MSS 씩 증가시킨다. 따라서, 혼잡 회피는 선형 증가 형태를 띈다.
- 타임아웃이 발생하면, 슬로 스타트에서와 동일하게 cwnd 값은 1MSS로, ssthresh 값을 cwnd/2 로 설정한 뒤 **빠른 회복** 상태로 진입한다.
- 3개의 중복 ACK을 받으면, cwnd 크기를 현재의 절반으로 줄이고, **빠른 회복** 상태로 진입한다.

<br>

# 빠른 회복

- 빠른 회복에서는 cwnd 값을 잃었던 세그먼트에 대한 매 중복된 ACK를 수신할 때마다 1MSS 씩 증가시킨다.
- 타임아웃이 발생하면, 슬로 스타트와 혼잡 회피에서와 동일한 작업을 수행한 후 **슬로 스타트**로 진입한다.