---
title: "[면접 예상 질문] 운영체제(2/3)"
date: 2021-1-15 19:23:00 +0900
categories:
  - 면접 예상 질문
toc: true
classes: wide
use_math: true
---

# 1. 상대 주소와 절대 주소란?

- 상대 주소는 CPU가 생성하는 가상의 주소이고, 절대 주소는 메모리가 취급하는 물리 주소이다.
- 컴파일, 적재 시간에 주소를 바인딩하면 이 둘은 같지만, 실행 시간에 주소를 바인딩하면 같지 않다. 이 때 MMU가 가상 주소를 물리 주소로 바꿔준다.

<br>

# 2. 동적 적재(Dynamic Loading)이란?

- 프로세스가 시작될 때 프로세스 주소 공간 전체를 메모리에 올려 놓는 것이 아니라, 메모리를 좀 더 효율적으로 사용하기 위해, 필요한 루틴이 호출될 때 해당 루틴을 메모리에 적재하는 방식을 말한다.

<br>

# 3. 동적 링킹 라이브러리(Dynamic Link Library, DLL)이란?

- 라이브러리가 프로그램 내부에 있는 것이 아니라, 따로 독립적으로 실행 가능한 파일로 존재해다가 프로그램이 실행될 때 동적으로 링크되어 사용된다.
- DLL의 장점
    - 각 프로세스에 라이브러리를 포함시키지 않아도 되므로 메인 메모리를 낭비하지 않는다.
    - 여러 프로세스 간에 공유가 가능하다.

<br>

# 4. 스와핑(Swapping)이란?

- 한 프로세스의 모든 이미지가 메모리로 적재되어 실행하다가, 더이상 실행되지 않을 경우 다시 디스크로 내려 보내는 방법이다.
- 현재 실행되고 있지 않은 프로세스는 메모리를 차지하지 않고 디스크에 존재하게 된다.

<br>

# 5. 메모리 배치 기법(사용할 수 있는 메모리 공간을 관리하는 방법) 세 가지를 설명.

1. 최초 적합(first-fit) : 첫 번째 가용 공간을 할당
2. 최적 적합(best-fit) : 요청한 크기에 가장 근접하게 큰 빈 공간을 할당
3. 최악 적합(worst-fit) : 가장 큰 가용 공간을 할당

<br>

# 6. 단편화(Fragmentation)란?

- 메모리의 빈 공간이 여러 개의 조각으로 나뉘는 현상

<br>

# 7. 외부 단편화와 내부 단편화 설명

- 외부 단편화 : 남은 유휴 공간들을 합치면 프로세스를 실행시키기에 충분한 공간이 되지만, 여러 조각들로 분산되어 있으므로, 작업을 받아들이지 못하는 상황을 말한다.
- 내부 단편화 : 메모리를 할당할 때, 프로세스가 필요한 양보다 더 큰 메모리가 할당되어 내부에 낭비되는 빈 공간이 생기는 현상을 말한다.

<br>

# 8. 단편화 해결 방법

1. 압축(compaction)
    - 메모리에 존재하는 단편화 영역들을 한 곳으로 밀착시켜 모음
    - 프로그램의 재배치가 필요함
2. 통합(coalescing)
    - 인접한 단편화 영역들을 합침
    - 프로그램 재배치가 필요하지 않음
3. 페이징
    - 가상 메모리를 같은 크기의 블록으로 나누고, 그 단위는 페이지(page)라고 한다.
    - 주기억장치를 나눈 조각을 프레임(frame)이라고 한다.
    - 외부 단편화는 해결 되지만, 내부 단편화는 해결되지 않는다.
4. 세그멘테이션(Segmentation)
    - 페이징 기법과 유사
    - 같은 크기로 나누지 않고 서로 다른 크기로 나누고, 그 단위는 세그먼트(segment)라고 한다.
    - 내부 단편화는 해결 되지만, 외부 단편화는 해결되지 않는다.
5. 메모리 풀(Memory Pool)
    - 메모리의 일정 공간을 미리 할당하고, 동적 할당을 해 그 공간을 채워주는 기법.
    - 할당 받았던 메모리 공간 사용이 끝나면 반납하기 때문에 외부 단편화가 생기지 않는다.
    - 필요한 크기만큼 할당을 해놓기 때문에 내부 단편화 또한 생기지 않는다.
    - 내부 단편화, 외부 단편화 둘 다 해결 가능

<br>

# 9. 페이징(Paging)이란?

- 논리 주소 공간이 물리 메모리 공간에 연속적으로 들어가야 하는 제약을 해결하는 방법.
- 논리 주소 공간의 단위인 페이지를 물리 주소 공간 단위인 프레임에 매핑시킨다.
- 이를 위해선 논리 주소 공간과 물리 주소 공간을 분리해야 하며, 논리 주소와 물리 주소 변환을 위해 MMU(Memory Management Unit)의 도움을 받아야 한다.

<br>

# 10. Translation Look-Aside Buffer(TLB)이란?

- MMU 내부에 위치하는 고속 캐시의 일종으로, 페이지 테이블 참조 없이 가상 주소(논리 주소)를 물리 주소로 매핑할 수 있는 작은 하드웨어다.

<br>

# 11. 가상 메모리란?

- 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법이다.
- 더 많은 프로세스들이 동시에 실행될 수 있고 더 빨리 실행될 수 있다.
- 프로세스끼리 메모리를 공유할 수 있다는 장점도 있다.

<br>

# 12. 요구 페이징(Demand Paging)이란?

- 필요할 때만 페이지를 메모리에 적재하는 방식.
- 순수 요구 페이징(Pure Demand Paging) : 페이지가 필요해지기 전에는 결코 그 페이지를 메모리로 적재하지 않는 방식.

<br>

# 13. 페이지 폴트(Page Fault) 란?

- 메모리에 올라와있지 않은 페이지를 접근하려고 하는 상황.

<br>

# 14. 실질 메모리 접근 시간, 유효 접근 시간(Effective Access Time)이란?

- CPU가 요구할 때 메모리를 통해 읽혀지는 평균 시간을 말한다.
- 페이지 폴트 빈도에 따라 메모리에 접근하는 접근 시간이 달라지기 때문에, 페이지 폴트 확률(p)을 통해 유효 접근 시간을 구한다.
- \$Teff = (1-p)Tm + pTp$<br>(p : 페이지 폴트 확률, Tm : 메모리를 읽는 시간, Tp : 페이지 폴트가 발생했을 때 소요되는 시간)

<br>

# 15. 참조 지역성(Locality of reference) 이란?

- 프로그램은 실행 중 어느 한 특정 부분만 한동안 집중적으로 액세스하는 특성.
- 참조 지역성은 크게 세 가지로 나뉜다.
    1. 공간 지역성 : 참조된 메모리 근처의 메모리를 참조.
    2. 시간 지역성 : 참조했던 메모리는 빠른 시간 내 다시 참조될 수 있음.
    3. 순차 지역성 : 데이터가 순차적으로 액세스 됨.

<br>

# 16. 페이지 교체란?

- 페이지 폴트 발생 시, 새로 진입할 페이지를 위한 공간을 만들기 위해 이미 존재하고 있는 페이지 중 하나를 내보내는 것.

<br>

# 17. 기본적인 페이지 교체 알고리즘의 과정은?

1. 먼저 보조저장장치에서 페이지의 위치를 찾는다.
2. 빈 페이지 프레임을 찾는다.
    - 비어있다면 그걸 사용
    - 비어있지 않다면 희생 프레임을 선정하기 위해 페이지 교체 알고리즘을 수행
    - 필요한 경우 내보낼 페이지를 보조저장장치에 기록, 관련 테이블을 수정
3. 새로 비워진 프레임에 새 페이지를 읽어오고 테이블을 수정
4. 페이지 폴트가 발생한 시점에서 프로세스를 재개

<br>

# 18. FIFO(First-In-First-Out) 페이지 교체 알고리즘이란?

- 메모리에 올라온 가장 오래된 페이지를 내쫓음

<br>

# 19. 최적(Optimal) 페이지 교체 알고리즘이란?

- 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체

<br>

# 20. LRU(Least Recently Used) 페이지 교체 알고리즘이란? 직접 구현하려면 어떤 자료구조를 써야할까?

- 페이지마다 마지막 사용 시간을 기록해 가장 오랫동안 사용되지 않은 페이지를 교체
- **직접 구현**하려면 LinkedHashMap을 쓰면 된다.
- LRU 구현 자체는 간단하게 하려면 PriorityQueue를 사용하면 되는데, 정렬하는데 소요되는 log n 조차 O(1)로 하기 위해서 DoubleLinkedList와 HashMap을 사용한다.

<br>

# 21. LFU(Least Frequently Used) 페이지 교체 알고리즘이란?

- 참조 횟수가 가장 적은 페이지를 교체

<br>

# 22. MFU(Most Frequently Used) 페이지 교체 알고리즘이란?

- 참조 횟수가 가장 큰 페이지를 교체

<br>

# 23. 페이징과 세그멘테이션(Segmentation)의 차이?

- 페이징 : 논리 메모리는 고정 크기의 블록 페이지(page)로 나뉘어지고, 물리 메모리는 고정 크기의 프레임(frame)이라 불리는 페이지와 같은 크기의 블록들로 분할한다.
- 세그멘테이션 : 페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적인 단위인 세그먼트(segment)로 분할한다.

<br>

# 24. 쓰기 시 복사(Copy-on-Write)는 언제 일어나는가?

- 부모 프로세스가 fork() 시스템 콜을 호출해 자식 프로세스를 생성하면, 부모 프로세스의 페이지들을 자식 프로세스에 복사해준다.
- 대부분의 자식 프로세스는 fork() 로 만들어지자마자 exec() 시스템 콜을 한다. 그럼 부모로부터 받은 페이지들은 다 쓸모없어진다.
- 자식 프로세스는 부모 프로세스의 페이지를 당분간 함께 사용한다. 이처럼 공유되는 페이지를 **쓰기 시 복사 페이지**라고 한다. 자식은 읽기(read) 작업할 때는 부모의 페이지를 사용하고, 쓰기(write)시그 페이지를 복사해놓고 복사된 페이지에 수정을 가한다.
- 요구 페이징에 비해 자식 프로세스의 생성 시간도 줄일 수 있고, 자식에게 할당된 페이지 수도 줄일 수 있다.

<br>

# 25. 페이지 교체가 일어날 때 전역 교체와 지역 교체의 차이점은?

- 전역 교체 : 모든 페이지 프레임이 교체 대상이 될 수 있는 방법이다.
- 지역 교체 : 현재 수행중인 프로세스에게 할당된 프레임 내에서만 교체 대상을 선정할 수 있는 방법이다.
- 전역 교체는 효율성은 좋은데, 다른 프로세스의 페이지 교체에 영향을 줄 수 있다는 단점이, 지역 교체는 안정성쪽은 좋은데 효율성은 떨어진다는 단점이 있다.

<br>

# 26. 스래싱(Thrashing) 이란? 스래싱 해결 방법은?

- 충분한 페이지 프레임을 갖지 못해 프로세스가 계속적으로 페이지 폴트를 발생시켜 프로세스의 처리 시간보다 페이지를 교체하는 데 더 많은 시간을 소모하는 현상.
- 프로세스를 종료시켜 프로세스의 적절한 수를 유지함으로써 해결할 수 있다.

<br>

# 27. 작업 집합(Working-Set)이란?

- 한 프로세스가 최근 n번 페이지를 참조했다면, 그 안에 들어있는 서로 다른 페이지들의 집합을 말한다.
- 페이지가 활발하게 사용되었다면 작업 집합에 포함된다. 더이상 사용되지 않게 되면 마지막 참조로부터 n만큼의 페이지 참조 후에는 작업 집합에서 제외된다.
- n값이 너무 작으면 전체 지역을 포함하지 못하고, 너무 크면 여러 지역성을 과도하게 포괄할 것이다.

<br>

# 28. 디스크 스케줄링의 목적?

- 디스크 헤드의 이동을 최소화하여 탐색 시간을 줄이는 데 있다.

<br>

# 29. SCAN 스케줄링이란?

- 디스크 암이 디스크 한쪽 끝에서 시작해 다른 끝으로 이동하며, 가는 길에 있는 요청을 모두 처리한다.

<br>

# 30. C-SCAN 스케줄링이란?

- SCAN 스케줄링 알고리즘의 파생.
- 다른 한쪽 끝으로 이동할 때 서비스 하지 않고 이동만 함.

<br>

# 31. RAID(Redundant Array of Independent Disks) 란?

- 전체 성능 향상을 위해 동일한 데이터를 분산해 여러 드라이브에 중복 저장하는 방식

<br>

# 32. 포트와 버스란?

- 포트 : 하드웨어와 컴퓨터 시스템을 연결하는 지점
- 버스 : 하나 이상의 장치들이 공동으로 연결되어 있는 여러 선

<br>

# 33. 폴링(polling)이란? 폴링과 바쁜 대기(busy-waiting)의 차이점은?

- 운영체제가 하드웨어 장치의 상태 레지스터를 읽음으로써 명령의 수신 여부를 주기적으로 확인하는 것
- **폴링**은 주기적으로 확인하며 다른 일을 수행하지만, **바쁜 대기**는 block 된 채로 확인만 계속 한다.

<br>

# 34. 인터럽트(interrupt)와 트랩(trap)이란?

- CPU 하드웨어는 **인터럽트 요청 라인**(interrupt request line)이라는 한 선을 갖는데, CPU는 각 명령어를 끝내고 다음 명령어를 수행하기 전에 항상 이 선을 검사한다.
- **인터럽트**는 입출력 컨트롤러가 인터럽트 요청 라인에 신호를 보내면 CPU가 알아차리고 각종 레지스터 값과 상태 정보를 저장한 다음, **인터럽트 핸들러 함수**로 분기하는 행위를 말한다.
- **트랩**은 소프트웨어 인터럽트라고도 불린다.
- 인터럽트는 하드웨어적으로 프로그램 외부에서 발생하는 것이며 또한 언제 발생할 지 예상을 못해 **비동기적**이며, 트랩은 프로그램 내부 일정 지점에서 발생해 **동기적**이다.

<br>

# 35. 직접 메모리 접근(Direct Memory Access, DMA)이란?

- CPU가 직접 입출력을 관리하지 않고, DMA 컨트롤러라 불리는 특수 프로세서에 위임함으로써 CPU의 일이 줄어든다.

<br>

# 36. 버퍼링(Buffering)이란?

- **버퍼**는 두 장치 또는 장치와 응용 프로그램 사이에 데이터가 전송되는 동안 전송 데이터를 임시로 저장하는 메모리 영역을 말한다.
- **버퍼링**은 데이터의 생산자와 소비자 사이에 속도가 다르므로, 버퍼에 자료 전체가 다 도착하면 한번에 드라이브에 기록하는 행위를 말한다.

<br>

# 37. 캐싱(Caching)이란?

- **캐시**는 자주 사용될 자료의 복사본을 저장하는 빠른 메모리 영역이다.
- 캐시된 복사본을 사용하면, 원래 자료를 사용하는 것보다 더 빠르기에 효율적이다.

<br>

# 38. 스풀링(Spooling)이란?

- **스풀**은 인터리브(interleave)하게 동작할 수 없는 장치들을 위해 출력 데이터를 보관하는 버퍼이다.
- **스풀링**은 스풀을 활용해 데이터를 디스크의 공간을 잡아서 버퍼링 해놓는 행위를 말한다.